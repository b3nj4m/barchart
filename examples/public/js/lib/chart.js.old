define([
  'd3',
  'handlebars'
],
function(d3, Handlebars) {
  var Chart = function(container, data) {
    if (container === undefined)
      this.container_elem = document.body;
    else
      this.container_elem = container;
    this.container = d3.select(this.container_elem);

    if (data === undefined || data === null)
      this.data = [];
    else
      this.data = data;

    this.make_accessors();
  };

  Chart.prototype.make_accessors = function() {
    var chart = this;
    this.data_value_accessor = function(d) {
      if (d !== undefined && d !== null)
        return d[chart.data_value_key];
    };
    this.label_top_accessor = function(d) {
      if (d !== undefined && d !== null)
        return d[chart.label_top_key];
    };
    this.label_inside_accessor = function(d) {
      if (d !== undefined && d !== null)
        return d[chart.label_inside_key];
    };
    this.data_id_key_accessor = function(d) {
      if (d !== undefined && d !== null)
        return d[chart.data_id_key];
    };
  };

  Chart.prototype.template_data_value_accessor = function(d) {
    return d.value;
  };

  Chart.prototype.template_data_label_top_accessor = function(d) {
    return d.label_top;
  };

  Chart.prototype.template_data_label_inside_accessor = function(d) {
    return d.label_inside;
  };

  Chart.prototype.animation_delay = function(d, i) {
    return i * 100;
  };

  Chart.prototype.has_rendered = false;
  Chart.prototype.is_animated = true;
  Chart.prototype.animation_duration = 400;
  Chart.prototype.auto_scale = false; //TODO height scaling?
  Chart.prototype.bar_color = '#00AB8E';
  Chart.prototype.bar_spacing = 20;
  Chart.prototype.chart_padding = 10;
  Chart.prototype.data = null;
  Chart.prototype.data_value_key = 'value';
  Chart.prototype.data_id_key = 'id';
  Chart.prototype.height = 300;
  Chart.prototype.width = 700;
  Chart.prototype.label_top_color = '#003D4C';
  Chart.prototype.label_inside_color = '#FFF';
  Chart.prototype.label_inside_key = 'value';
  Chart.prototype.label_padding = 3;
  Chart.prototype.label_size = 16;
  Chart.prototype.label_top_key = 'label_top';

  //yes, it's ugly. (⌐■_■) deal with it.
  Chart.prototype.template = Handlebars.compile('\
  <div style="position: relative;" class="chart-container">\
    <svg style="width: {{width}}px; height: {{height}}px;" xmlns="http://www.w3.org/2000/svg" version="1.1">\
      {{#each template_data}}\
        <g class="bar-container">\
          <g class="bar">\
            <rect width="{{width}}" height="{{height}}" x="{{x}}" y="{{y}}" style="fill: {{../bar_color}};" />\
          </g>\
        </g>\
      {{/each}}\
    </svg>\
    {{#each template_data}}\
      <div class="label-top" style="\
        font-size: {{../label_size}}px;\
        font-weight: bold;\
        line-height: {{../label_size}}px;\
        padding: {{../label_padding}}px;\
        width: {{../label_width}}px;\
        left: {{label_top_x}}px;\
        top: {{label_top_y}}px;\
        text-align: center;\
        position: absolute;\
        color: {{../label_top_color}};\
      ">{{label_top}}</div>\
      <div class="label-inside" style="\
        font-size: {{../label_size}}px;\
        font-weight: bold;\
        line-height: {{../label_size}}px;\
        width: {{../label_width}}px;\
        height: {{label_inside_height}}px;\
        left: {{label_inside_x}}px;\
        top: {{label_inside_y}}px;\
        position: absolute;\
        color: {{../label_inside_color}};\
      ">\
        <div style="\
          position: absolute;\
          bottom: {{../label_padding}}px;\
          left: {{../label_padding}}px;\
          text-align: center;\
          width: 100%;\
          max-height: {{label_inside_height}}px;\
          overflow: hidden;\
        ">\
          {{label_inside}}\
        </div>\
      </div>\
    {{/each}}\
  </div>\
  ');
  
  Chart.prototype.compute_boundaries = function() {
    if (this.auto_scale) {
      this.width = this.container_elem.scrollWidth || this.width;
    }

    this.min_bar_size = this.label_size + this.label_padding * 2;
    this.max_bar_size = Math.max(this.min_bar_size, this.height - this.chart_padding - this.label_size - this.label_padding * 2);
    this.data_min = d3.min(this.data, this.data_value_accessor);
    this.data_max = d3.max(this.data, this.data_value_accessor);

    this.bar_width = Math.floor((this.width - this.chart_padding * 2 - (this.data.length - 1) * this.bar_spacing) / this.data.length);
    this.label_width = this.bar_width - this.label_padding * 2;

    var height_scale = d3.scale.linear().domain([this.data_min, this.data_max]).range([this.min_bar_size, this.max_bar_size])
    this.height_scale = height_scale;

    this.x_scale = d3.scale.linear().domain([0, this.data.length - 1]).range([this.chart_padding, this.width - this.chart_padding - this.bar_width])

    var baseline = this.height - this.chart_padding;
    var y_scale = function(val) {
      return baseline - height_scale(val);
    };
    this.y_scale = y_scale;

    var label_padding = this.label_padding;
    var label_size = this.label_size;
    this.label_top_y_scale = function(val) {
      return y_scale(val) - label_padding * 2 - label_size;
    };
  };

  Chart.prototype.render = function() {
    //TODO use enter and exit selections to transition existing elements
    if (this.has_rendered) {
      this.container.html('');
      this.has_rendered = false;
    }

    if (this.data === undefined || this.data === null || this.data.length == 0)
      return;

    this.compute_boundaries();

    this.template_data = [];
    var x, y, height, value;
    for (var i = 0; i < this.data.length; i++) {
      value = this.data_value_accessor(this.data[i]);
      x = this.x_scale(i);
      y = this.y_scale(value);
      height = this.height_scale(value);

      this.template_data.push({
        value: this.data_value_accessor(this.data[i]),
        width: this.bar_width,
        height: height,
        x: x,
        y: y,
        label_inside: this.label_inside_accessor(this.data[i]),
        label_inside_x: x,
        label_inside_y: y,
        label_inside_height: height,
        label_top: this.label_top_accessor(this.data[i]),
        label_top_x: x,
        label_top_y: this.label_top_y_scale(value)
      });
    }

    if (this.is_animated) {
      for (i in this.template_data) {
        if (this.template_data[i] === undefined || this.template_data[i] === null)
          continue;

        this.template_data[i].final_height = this.template_data[i].height;
        this.template_data[i].final_label_top_y = this.template_data[i].label_top_y;
        this.template_data[i].final_y = this.template_data[i].y;
        this.template_data[i].final_label_inside = this.template_data[i].label_inside;

        this.template_data[i].height = this.height_scale(this.data_min);
        this.template_data[i].label_top_y = this.label_top_y_scale(this.data_min);
        this.template_data[i].y = this.y_scale(this.data_min);
        this.template_data[i].label_inside = this.data_min;
      }
    }

    this.container.html(this.template(this));

    var bars = this.container.selectAll('.bar-container .bar rect').data(this.template_data, this.data_id_key_accessor);
    var labels_top = this.container.selectAll('.label-top').data(this.template_data, this.data_id_key_accessor);
    var labels_inside_containers = this.container.selectAll('.label-inside').data(this.template_data, this.data_id_key_accessor);
    var labels_inside = this.container.selectAll('.label-inside div').data(this.template_data, this.data_id_key_accessor);
    
    if (this.is_animated) {
      bars.transition()
        .delay(this.animation_delay)
        .duration(this.animation_duration)
        .attr('height', function(d, i) {
          return d.final_height;
        })
        .attr('y', function(d, i) {
          return d.final_y;
        });
      labels_top.transition()
        .delay(this.animation_delay)
        .duration(this.animation_duration)
        .style('top', function(d, i) {
          return d.final_label_top_y + 'px';
        });
      var data_min = this.data_min;
      labels_inside.transition()
        .delay(this.animation_delay)
        .duration(this.animation_duration)
        .tween('label_inside_text', function(d) {
          var i = d3.interpolateRound(data_min, parseInt(d.final_label_inside));
          return function(t) {
            this.textContent = i(t);
          };
        });
    }

    this.has_rendered = true;
  };

  return Chart;
});
